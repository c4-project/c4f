#!/usr/bin/env bash
#
# Quick wrapper for checking the states of one C test.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
readonly SCRIPTDIR

# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"

## Constants and arguments ##

# The backend ID to use to get state sets.
#Â If empty, an arbitrary local backend (herd-style if compiler is empty,
# litmus-style otherwise) is chosen.
BACKEND=""

# If nonempty, specifies a compiler to use with `c_litmus_indirect`: this
# script will then go through `c_litmus_indirect` instead of directly running
# the backend.
COMPILER=""

# Whether or not we're running ACT programs through `dune exec`.
DUNE_EXEC="false"

# Whether or not verbose logging is enabled.
VERBOSE="false"

## Functions ##

# Prints usage information and exits.
usage() {
  echo "Usage: $0 [-b BACKEND] [-c COMPILER] [-qvxh?] C_TEST"
  echo
  echo "-b: ID of backend to use for checking C files"
  echo "-c: ID of compiler to use (if given, c_litmus_indirect is used)"
  echo "-v/-q: verbose/quiet"
  echo "-x: run ACT binaries with \`dune exec\`"
  echo "-h/-?: usage"
  exit
}

# Runs the appropriate pipeline to generate a state JSON output.
#
# Globals:
#   - BACKEND (read)
#   - COMPILER (read)
#
# Arguments:
#   1: the file containing the C litmus test to simulate or execute.
run() {
  local infile="$1"

  if [[ -n ${COMPILER} ]]; then
    act::log "Using c_litmus_indirect, backend '%s', compiler '%s', target '%s'.\n" "${BACKEND}" "${COMPILER}" "${infile}"
    flags="-q"
    if [[ ${VERBOSE} = "true" ]]; then flags="-v"; fi
    if [[ ${DUNE_EXEC} = "true" ]]; then flags="${flags}x"; fi
    "${SCRIPTDIR}/c_litmus_indirect" ${flags} -b "${BACKEND}" -c "${COMPILER}" "${infile}"
  else
    act::log "Using backend '%s' directly, target '%s'.\n" "${BACKEND}" "${infile}"
    act::backend run -c -backend "${BACKEND}" "${infile}" | act::backend parse -backend "${BACKEND}"
  fi
}

# Main function.
main() {
  while getopts "b:c:qvx?h" a; do
    case ${a} in
    b) BACKEND=${OPTARG} ;;
    c) COMPILER=${OPTARG} ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  readonly COMPILER VERBOSE DUNE_EXEC
  shift $((OPTIND-1))

  if [[ ${DUNE_EXEC} = "true" ]]; then
    act::log "%s: using 'dune exec' for ACT.\n" "$0"
  fi

  if [[ -z "${BACKEND}" ]]; then
    local style="herd"
    if [[ -n "${COMPILER}" ]]; then style="litmus"; fi

    BACKEND="$("${SCRIPTDIR}/get_a_backend" -l -s ${style})"
    act::log "Defaulted to backend %s.\n" "${BACKEND}"
  fi
  readonly BACKEND

  if [[ $# -ne 1 ]]; then
    act::error "expected precisely one anonymous argument"
    usage
  fi
  local infile="$1"

  run "${infile}"
}

## Entry point ##

main "$@"
