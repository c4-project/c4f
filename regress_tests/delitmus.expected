# Delitmus tests

## deacon.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
void
P0()
{
    atomic_store_explicit(&x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
}
void
P1()
{
    atomic_fetch_add_explicit(&y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    r0 = atomic_load_explicit(&x, memory_order_relaxed);
}
void
P2()
{ r1 = atomic_load_explicit(&y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 0 /\\ 2:r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
void
P0_body()
{
    atomic_store_explicit(&x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
}
void
P1_body()
{
    atomic_fetch_add_explicit(&y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    r0 = atomic_load_explicit(&x, memory_order_relaxed);
}
void
P2_body()
{ r1 = atomic_load_explicit(&y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 0 /\\ 2:r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t1r0 = 0;
int t2r1 = 0;
void
P0()
{
    atomic_store_explicit(&x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
}
void
P1()
{
    atomic_fetch_add_explicit(&y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    t1r0 = atomic_load_explicit(&x, memory_order_relaxed);
}
void
P2()
{ t2r1 = atomic_load_explicit(&y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 0 /\\ t2r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t1r0 = 0;
int t2r1 = 0;
void
P0_body()
{
    atomic_store_explicit(&x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
}
void
P1_body()
{
    atomic_fetch_add_explicit(&y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    t1r0 = atomic_load_explicit(&x, memory_order_relaxed);
}
void
P2_body()
{ t2r1 = atomic_load_explicit(&y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 0 /\\ t2r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(y, 1, memory_order_relaxed);
}
void
P1(atomic_int *x, atomic_int *y, int *r0)
{
    atomic_fetch_add_explicit(y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    *r0 = atomic_load_explicit(x, memory_order_relaxed);
}
void
P2(atomic_int *x, atomic_int *y, int *r1)
{ *r1 = atomic_load_explicit(y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 0 /\\ 2:r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(y, 1, memory_order_relaxed);
}
void
P1_body(atomic_int *x, atomic_int *y, int *r0)
{
    atomic_fetch_add_explicit(y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    *r0 = atomic_load_explicit(x, memory_order_relaxed);
}
void
P2_body(atomic_int *x, atomic_int *y, int *r1)
{ *r1 = atomic_load_explicit(y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 0 /\\ 2:r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(y, 1, memory_order_relaxed);
}
void
P1(atomic_int *x, atomic_int *y, int *t1r0)
{
    atomic_fetch_add_explicit(y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    *t1r0 = atomic_load_explicit(x, memory_order_relaxed);
}
void
P2(atomic_int *x, atomic_int *y, int *t2r1)
{ *t2r1 = atomic_load_explicit(y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 0 /\\ t2r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(x, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    atomic_store_explicit(y, 1, memory_order_relaxed);
}
void
P1_body(atomic_int *x, atomic_int *y, int *t1r0)
{
    atomic_fetch_add_explicit(y, 1, memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    *t1r0 = atomic_load_explicit(x, memory_order_relaxed);
}
void
P2_body(atomic_int *x, atomic_int *y, int *t2r1)
{ *t2r1 = atomic_load_explicit(y, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "deacon2018_big",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 0 /\\ t2r1 == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## fuzz_local_bools.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int clumsy_unicorn_10 = -2;
int game_11 = 230;
atomic_int gentle_corridor = -444497203;
atomic_int x = 0;
atomic_int y = 0;
int zebra = 325;
int volatile r0 = 0;
atomic_bool volatile asymptote = false;
atomic_int volatile kelp_10 = 17107;
void
P0()
{
    if (!!(0 == atomic_fetch_xor_explicit(&y, 0, memory_order_acq_rel))) {  }
    yam: ;
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(&gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1()
{
    humble_llama_11: ;
    atomic_store_explicit(&y, 2, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2()
{
    if (atomic_load_explicit(&kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(&x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(&x,
                                  atomic_fetch_sub_explicit(&y,
                                                            atomic_fetch_add_explicit
                                                            (&kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (&kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(&kelp_10,
                                  atomic_fetch_add_explicit(&y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(&kelp_10,
                                  atomic_load_explicit(&gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(&gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ 0:r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ 0:r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ 0:r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Global" ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Global" ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Global" ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Global" ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "asymptote",
      "mapped_to": [ "Global" ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "kelp_10",
      "mapped_to": [ "Global" ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int clumsy_unicorn_10 = -2;
int game_11 = 230;
atomic_int gentle_corridor = -444497203;
atomic_int x = 0;
atomic_int y = 0;
int zebra = 325;
int volatile r0 = 0;
atomic_bool volatile asymptote = false;
atomic_int volatile kelp_10 = 17107;
void
P0_body()
{
    if (!!(0 == atomic_fetch_xor_explicit(&y, 0, memory_order_acq_rel))) {  }
    yam: ;
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(&gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1_body()
{
    humble_llama_11: ;
    atomic_store_explicit(&y, 2, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2_body()
{
    if (atomic_load_explicit(&kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(&x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(&x,
                                  atomic_fetch_sub_explicit(&y,
                                                            atomic_fetch_add_explicit
                                                            (&kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (&kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(&kelp_10,
                                  atomic_fetch_add_explicit(&y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(&kelp_10,
                                  atomic_load_explicit(&gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(&gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ 0:r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ 0:r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ 0:r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Global" ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Global" ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Global" ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Global" ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "asymptote",
      "mapped_to": [ "Global" ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "kelp_10",
      "mapped_to": [ "Global" ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int clumsy_unicorn_10 = -2;
int game_11 = 230;
atomic_int gentle_corridor = -444497203;
atomic_int x = 0;
atomic_int y = 0;
int zebra = 325;
int volatile t0r0 = 0;
atomic_bool volatile t1asymptote = false;
atomic_int volatile t2kelp_10 = 17107;
void
P0()
{
    if (!!(0 == atomic_fetch_xor_explicit(&y, 0, memory_order_acq_rel))) {  }
    yam: ;
    t0r0 = atomic_load_explicit(&x, memory_order_acquire);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(&gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1()
{
    humble_llama_11: ;
    atomic_store_explicit(&y, 2, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2()
{
    if (atomic_load_explicit(&t2kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(&x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(&x,
                                  atomic_fetch_sub_explicit(&y,
                                                            atomic_fetch_add_explicit
                                                            (&t2kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (&t2kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(&t2kelp_10,
                                  atomic_fetch_add_explicit(&y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(&t2kelp_10,
                                  atomic_load_explicit(&gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(&gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ t0r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ t0r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ t0r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Global" ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Global" ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Global" ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Global" ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "t1asymptote",
      "mapped_to": [ "Global" ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "t2kelp_10",
      "mapped_to": [ "Global" ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int clumsy_unicorn_10 = -2;
int game_11 = 230;
atomic_int gentle_corridor = -444497203;
atomic_int x = 0;
atomic_int y = 0;
int zebra = 325;
int volatile t0r0 = 0;
atomic_bool volatile t1asymptote = false;
atomic_int volatile t2kelp_10 = 17107;
void
P0_body()
{
    if (!!(0 == atomic_fetch_xor_explicit(&y, 0, memory_order_acq_rel))) {  }
    yam: ;
    t0r0 = atomic_load_explicit(&x, memory_order_acquire);
    atomic_store_explicit(&y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(&gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1_body()
{
    humble_llama_11: ;
    atomic_store_explicit(&y, 2, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2_body()
{
    if (atomic_load_explicit(&t2kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(&x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(&x,
                                  atomic_fetch_sub_explicit(&y,
                                                            atomic_fetch_add_explicit
                                                            (&t2kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (&t2kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(&t2kelp_10,
                                  atomic_fetch_add_explicit(&y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(&t2kelp_10,
                                  atomic_load_explicit(&gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(&gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ t0r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ t0r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ t0r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Global" ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Global" ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Global" ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Global" ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "t1asymptote",
      "mapped_to": [ "Global" ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "t2kelp_10",
      "mapped_to": [ "Global" ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra, int volatile *r0)
{
    if (!!(0 == atomic_fetch_xor_explicit(y, 0, memory_order_acq_rel))) {  }
    yam: ;
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    atomic_store_explicit(y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra, atomic_bool volatile *asymptote)
{
    humble_llama_11: ;
    atomic_store_explicit(y, 2, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra, atomic_int volatile *kelp_10)
{
    if (atomic_load_explicit(kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(x,
                                  atomic_fetch_sub_explicit(y,
                                                            atomic_fetch_add_explicit
                                                            (kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(kelp_10,
                                  atomic_fetch_add_explicit(y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(kelp_10,
                                  atomic_load_explicit(gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ 0:r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ 0:r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ 0:r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Param", 0 ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Param", 2 ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 4 ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "r0",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "asymptote",
      "mapped_to": [ "Param", 6 ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "kelp_10",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra, int volatile *r0)
{
    if (!!(0 == atomic_fetch_xor_explicit(y, 0, memory_order_acq_rel))) {  }
    yam: ;
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    atomic_store_explicit(y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra,
        atomic_bool volatile *asymptote)
{
    humble_llama_11: ;
    atomic_store_explicit(y, 2, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra,
        atomic_int volatile *kelp_10)
{
    if (atomic_load_explicit(kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(x,
                                  atomic_fetch_sub_explicit(y,
                                                            atomic_fetch_add_explicit
                                                            (kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(kelp_10,
                                  atomic_fetch_add_explicit(y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(kelp_10,
                                  atomic_load_explicit(gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ 0:r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ 0:r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ 0:r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Param", 0 ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Param", 2 ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 4 ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "r0",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "asymptote",
      "mapped_to": [ "Param", 6 ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "kelp_10",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra, int volatile *t0r0)
{
    if (!!(0 == atomic_fetch_xor_explicit(y, 0, memory_order_acq_rel))) {  }
    yam: ;
    *t0r0 = atomic_load_explicit(x, memory_order_acquire);
    atomic_store_explicit(y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra,
   atomic_bool volatile *t1asymptote)
{
    humble_llama_11: ;
    atomic_store_explicit(y, 2, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
   atomic_int *x, atomic_int *y, int *zebra, atomic_int volatile *t2kelp_10)
{
    if (atomic_load_explicit(t2kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(x,
                                  atomic_fetch_sub_explicit(y,
                                                            atomic_fetch_add_explicit
                                                            (t2kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (t2kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(t2kelp_10,
                                  atomic_fetch_add_explicit(y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(t2kelp_10,
                                  atomic_load_explicit(gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ t0r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ t0r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ t0r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Param", 0 ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Param", 2 ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 4 ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "t1asymptote",
      "mapped_to": [ "Param", 6 ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "t2kelp_10",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra, int volatile *t0r0)
{
    if (!!(0 == atomic_fetch_xor_explicit(y, 0, memory_order_acq_rel))) {  }
    yam: ;
    *t0r0 = atomic_load_explicit(x, memory_order_acquire);
    atomic_store_explicit(y, 1, memory_order_relaxed);
    atomic_fetch_and_explicit(gentle_corridor, -444497203,
                              memory_order_seq_cst);
}
void
P1_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra,
        atomic_bool volatile *t1asymptote)
{
    humble_llama_11: ;
    atomic_store_explicit(y, 2, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_release);
    map: ;
    atomic_signal_fence(memory_order_consume);
}
void
P2_body(int *clumsy_unicorn_10, int *game_11, atomic_int *gentle_corridor,
        atomic_int *x, atomic_int *y, int *zebra,
        atomic_int volatile *t2kelp_10)
{
    if (atomic_load_explicit(t2kelp_10, memory_order_seq_cst) == 17107) 
    {  } else
    {
        return;
        ;
        atomic_fetch_add_explicit(x, 0, memory_order_relaxed);
        atomic_fetch_sub_explicit(x,
                                  atomic_fetch_sub_explicit(y,
                                                            atomic_fetch_add_explicit
                                                            (t2kelp_10, 0,
                                                             memory_order_relaxed)
                                                            -
                                                            atomic_fetch_add_explicit
                                                            (t2kelp_10, 0,
                                                             memory_order_relaxed),
                                                            memory_order_seq_cst)
                                  & 0, memory_order_seq_cst);
        atomic_fetch_add_explicit(t2kelp_10,
                                  atomic_fetch_add_explicit(y, 0,
                                                            memory_order_seq_cst),
                                  memory_order_seq_cst);
        atomic_fetch_add_explicit(t2kelp_10,
                                  atomic_load_explicit(gentle_corridor,
                                                       memory_order_consume),
                                  memory_order_seq_cst);
    }
    atomic_store_explicit(gentle_corridor, -444497203, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_9",
    "locations": null,
    "init": {
      "game_11": 230,
      "clumsy_unicorn_10": -2,
      "gentle_corridor": -444497203,
      "zebra": 325,
      "y": 0,
      "x": 0
    },
    "postcondition":
      "forall\n((x == 1 /\\ (y == 1 /\\ t0r0 == 0)) \\/\n ((x == 1 /\\ (y == 1 /\\ t0r0 == 1)) \\/ (x == 1 /\\ (y == 2 /\\ t0r0 == 0))))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "clumsy_unicorn_10": {
      "c_type": "int",
      "c_id": "clumsy_unicorn_10",
      "mapped_to": [ "Param", 0 ],
      "initial_value": -2
    },
    "game_11": {
      "c_type": "int",
      "c_id": "game_11",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 230
    },
    "gentle_corridor": {
      "c_type": "atomic_int",
      "c_id": "gentle_corridor",
      "mapped_to": [ "Param", 2 ],
      "initial_value": -444497203
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 4 ],
      "initial_value": 0
    },
    "zebra": {
      "c_type": "int",
      "c_id": "zebra",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 325
    },
    "0:r0": {
      "c_type": "volatile int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "1:asymptote": {
      "c_type": "volatile atomic_bool",
      "c_id": "t1asymptote",
      "mapped_to": [ "Param", 6 ],
      "initial_value": false
    },
    "2:kelp_10": {
      "c_type": "volatile atomic_int",
      "c_id": "t2kelp_10",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 17107
    }
  }
} 
--End auxiliary output-- */
```
## iriw.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
int r1 = 0;
void
P0()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P2()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P3()
{
    r0 = atomic_load_explicit(&y, memory_order_acquire);
    r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
int r1 = 0;
void
P0_body()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1_body()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P2_body()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P3_body()
{
    r0 = atomic_load_explicit(&y, memory_order_acquire);
    r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t2r0 = 0;
int t2r1 = 0;
int t3r0 = 0;
int t3r1 = 0;
void
P0()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P2()
{
    t2r0 = atomic_load_explicit(&x, memory_order_acquire);
    t2r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P3()
{
    t3r0 = atomic_load_explicit(&y, memory_order_acquire);
    t3r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t2r0 = 0;
int t2r1 = 0;
int t3r0 = 0;
int t3r1 = 0;
void
P0_body()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1_body()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P2_body()
{
    t2r0 = atomic_load_explicit(&x, memory_order_acquire);
    t2r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P3_body()
{
    t3r0 = atomic_load_explicit(&y, memory_order_acquire);
    t3r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P2(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P3(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(y, memory_order_acquire);
    *r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P2_body(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P3_body(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(y, memory_order_acquire);
    *r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P2(atomic_int *x, atomic_int *y, int *t2r0, int *t2r1)
{
    *t2r0 = atomic_load_explicit(x, memory_order_acquire);
    *t2r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P3(atomic_int *x, atomic_int *y, int *t3r0, int *t3r1)
{
    *t3r0 = atomic_load_explicit(y, memory_order_acquire);
    *t3r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P2_body(atomic_int *x, atomic_int *y, int *t2r0, int *t2r1)
{
    *t2r0 = atomic_load_explicit(x, memory_order_acquire);
    *t2r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P3_body(atomic_int *x, atomic_int *y, int *t3r0, int *t3r1)
{
    *t3r0 = atomic_load_explicit(y, memory_order_acquire);
    *t3r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "2:r1": {
      "c_type": "int",
      "c_id": "t2r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## iriw_fuzz_redundant.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int MaJgQmON3yu = 2728;
int VFTQNWN = -13;
int ZgoV7uel9o = 1073;
int m02M5s = -64856;
atomic_int ne0J8wrPQam = -12197004;
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
int r1 = 0;
void
P0()
{ atomic_store_explicit(&ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1()
{
    atomic_store_explicit(&ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_seq_cst);
}
void
P2()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P3()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
    atomic_store_explicit(&ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4()
{
    r0 = atomic_load_explicit(&y, memory_order_acquire);
    r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" },
    "P4": { "is_thread_body": true, "c_id": "P4" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Global" ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Global" ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Global" ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Global" ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Global" ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int MaJgQmON3yu = 2728;
int VFTQNWN = -13;
int ZgoV7uel9o = 1073;
int m02M5s = -64856;
atomic_int ne0J8wrPQam = -12197004;
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
int r1 = 0;
void
P0_body()
{ atomic_store_explicit(&ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1_body()
{
    atomic_store_explicit(&ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_seq_cst);
}
void
P2_body()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P3_body()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
    atomic_store_explicit(&ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4_body()
{
    r0 = atomic_load_explicit(&y, memory_order_acquire);
    r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" },
    "P4": { "is_thread_body": true, "c_id": "P4_body" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Global" ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Global" ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Global" ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Global" ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Global" ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int MaJgQmON3yu = 2728;
int VFTQNWN = -13;
int ZgoV7uel9o = 1073;
int m02M5s = -64856;
atomic_int ne0J8wrPQam = -12197004;
atomic_int x = 0;
atomic_int y = 0;
int t3r0 = 0;
int t3r1 = 0;
int t4r0 = 0;
int t4r1 = 0;
void
P0()
{ atomic_store_explicit(&ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1()
{
    atomic_store_explicit(&ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_seq_cst);
}
void
P2()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P3()
{
    t3r0 = atomic_load_explicit(&x, memory_order_acquire);
    t3r1 = atomic_load_explicit(&y, memory_order_seq_cst);
    atomic_store_explicit(&ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4()
{
    t4r0 = atomic_load_explicit(&y, memory_order_acquire);
    t4r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" },
    "P4": { "is_thread_body": true, "c_id": "P4" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Global" ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Global" ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Global" ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Global" ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Global" ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "t4r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "t4r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int MaJgQmON3yu = 2728;
int VFTQNWN = -13;
int ZgoV7uel9o = 1073;
int m02M5s = -64856;
atomic_int ne0J8wrPQam = -12197004;
atomic_int x = 0;
atomic_int y = 0;
int t3r0 = 0;
int t3r1 = 0;
int t4r0 = 0;
int t4r1 = 0;
void
P0_body()
{ atomic_store_explicit(&ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1_body()
{
    atomic_store_explicit(&ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(&x, 1, memory_order_seq_cst);
}
void
P2_body()
{ atomic_store_explicit(&y, 1, memory_order_seq_cst); }
void
P3_body()
{
    t3r0 = atomic_load_explicit(&x, memory_order_acquire);
    t3r1 = atomic_load_explicit(&y, memory_order_seq_cst);
    atomic_store_explicit(&ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4_body()
{
    t4r0 = atomic_load_explicit(&y, memory_order_acquire);
    t4r1 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" },
    "P4": { "is_thread_body": true, "c_id": "P4_body" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Global" ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Global" ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Global" ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Global" ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Global" ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "t4r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "t4r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_seq_cst);
}
void
P2(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P3(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
    atomic_store_explicit(ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(y, memory_order_acquire);
    *r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" },
    "P4": { "is_thread_body": true, "c_id": "P4" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Param", 1 ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Param", 3 ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Param", 4 ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_seq_cst);
}
void
P2_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P3_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *r0,
        int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
    atomic_store_explicit(ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *r0,
        int *r1)
{
    *r0 = atomic_load_explicit(y, memory_order_acquire);
    *r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (2:r0 == 1 /\\ 2:r1 == 0 /\\ 3:r0 == 1 /\\ 3:r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" },
    "P4": { "is_thread_body": true, "c_id": "P4_body" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Param", 1 ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Param", 3 ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Param", 4 ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_seq_cst);
}
void
P2(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P3(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *t3r0,
   int *t3r1)
{
    *t3r0 = atomic_load_explicit(x, memory_order_acquire);
    *t3r1 = atomic_load_explicit(y, memory_order_seq_cst);
    atomic_store_explicit(ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
   atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *t4r0,
   int *t4r1)
{
    *t4r0 = atomic_load_explicit(y, memory_order_acquire);
    *t4r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" },
    "P3": { "is_thread_body": true, "c_id": "P3" },
    "P4": { "is_thread_body": true, "c_id": "P4" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Param", 1 ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Param", 3 ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Param", 4 ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "t4r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "t4r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(ne0J8wrPQam, 3417, memory_order_seq_cst); }
void
P1_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{
    atomic_store_explicit(ne0J8wrPQam, 481486, memory_order_relaxed);
    atomic_store_explicit(x, 1, memory_order_seq_cst);
}
void
P2_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y)
{ atomic_store_explicit(y, 1, memory_order_seq_cst); }
void
P3_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *t3r0,
        int *t3r1)
{
    *t3r0 = atomic_load_explicit(x, memory_order_acquire);
    *t3r1 = atomic_load_explicit(y, memory_order_seq_cst);
    atomic_store_explicit(ne0J8wrPQam, -7, memory_order_seq_cst);
}
void
P4_body(int *MaJgQmON3yu, int *VFTQNWN, int *ZgoV7uel9o, int *m02M5s,
        atomic_int *ne0J8wrPQam, atomic_int *x, atomic_int *y, int *t4r0,
        int *t4r1)
{
    *t4r0 = atomic_load_explicit(y, memory_order_acquire);
    *t4r1 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "iriw",
    "locations": [
      "MaJgQmON3yu", "ZgoV7uel9o", "VFTQNWN", "m02M5s", "ne0J8wrPQam", "x",
      "y"
    ],
    "init": {
      "MaJgQmON3yu": 2728,
      "ZgoV7uel9o": 1073,
      "VFTQNWN": -13,
      "m02M5s": -64856,
      "ne0J8wrPQam": -12197004,
      "x": 0,
      "y": 0
    },
    "postcondition":
      "exists (t2r0 == 1 /\\ t2r1 == 0 /\\ t3r0 == 1 /\\ t3r1 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" },
    "P3": { "is_thread_body": true, "c_id": "P3_body" },
    "P4": { "is_thread_body": true, "c_id": "P4_body" }
  },
  "var_map": {
    "MaJgQmON3yu": {
      "c_type": "int",
      "c_id": "MaJgQmON3yu",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 2728
    },
    "VFTQNWN": {
      "c_type": "int",
      "c_id": "VFTQNWN",
      "mapped_to": [ "Param", 1 ],
      "initial_value": -13
    },
    "ZgoV7uel9o": {
      "c_type": "int",
      "c_id": "ZgoV7uel9o",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 1073
    },
    "m02M5s": {
      "c_type": "int",
      "c_id": "m02M5s",
      "mapped_to": [ "Param", 3 ],
      "initial_value": -64856
    },
    "ne0J8wrPQam": {
      "c_type": "atomic_int",
      "c_id": "ne0J8wrPQam",
      "mapped_to": [ "Param", 4 ],
      "initial_value": -12197004
    },
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 5 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 6 ],
      "initial_value": 0
    },
    "3:r0": {
      "c_type": "int",
      "c_id": "t3r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "3:r1": {
      "c_type": "int",
      "c_id": "t3r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    },
    "4:r0": {
      "c_type": "int",
      "c_id": "t4r0",
      "mapped_to": [ "Param", 7 ],
      "initial_value": 0
    },
    "4:r1": {
      "c_type": "int",
      "c_id": "t4r1",
      "mapped_to": [ "Param", 8 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## memalloy_cmpxchg.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int r0 = 0;
void
P0()
{
    r0 = 0;
    atomic_compare_exchange_strong_explicit(&x, &r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1()
{ atomic_store_explicit(&x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int r0 = 0;
void
P0_body()
{
    r0 = 0;
    atomic_compare_exchange_strong_explicit(&x, &r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body()
{ atomic_store_explicit(&x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int t0r0 = 0;
void
P0()
{
    t0r0 = 0;
    atomic_compare_exchange_strong_explicit(&x, &t0r0, 2,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1()
{ atomic_store_explicit(&x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int t0r0 = 0;
void
P0_body()
{
    t0r0 = 0;
    atomic_compare_exchange_strong_explicit(&x, &t0r0, 2,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body()
{ atomic_store_explicit(&x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, int *r0)
{
    *r0 = 0;
    atomic_compare_exchange_strong_explicit(x, r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1(atomic_int *x)
{ atomic_store_explicit(x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, int *r0)
{
    *r0 = 0;
    atomic_compare_exchange_strong_explicit(x, r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body(atomic_int *x)
{ atomic_store_explicit(x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, int *t0r0)
{
    *t0r0 = 0;
    atomic_compare_exchange_strong_explicit(x, t0r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1(atomic_int *x)
{ atomic_store_explicit(x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, int *t0r0)
{
    *t0r0 = 0;
    atomic_compare_exchange_strong_explicit(x, t0r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body(atomic_int *x)
{ atomic_store_explicit(x, 1, memory_order_relaxed); }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_7",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 2)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## memalloy_na_int.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int x = 0;
int r0 = 0;
void
P0()
{ x = 1; r0 = x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int x = 0;
int r0 = 0;
void
P0_body()
{ x = 1; r0 = x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0_body" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int x = 0;
int t0r0 = 0;
void
P0()
{ x = 1; t0r0 = x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
int x = 0;
int t0r0 = 0;
void
P0_body()
{ x = 1; t0r0 = x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0_body" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *x, int *r0)
{ *x = 1; *r0 = *x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *x, int *r0)
{ *x = 1; *r0 = *x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (0:r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0_body" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(int *x, int *t0r0)
{ *x = 1; *t0r0 = *x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(int *x, int *t0r0)
{ *x = 1; *t0r0 = *x; }

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_0",
    "locations": null,
    "init": { "x": 0 },
    "postcondition": "exists (t0r0 == 0 /\\ x == 1)"
  },
  "function_map": { "P0": { "is_thread_body": true, "c_id": "P0_body" } },
  "var_map": {
    "x": {
      "c_type": "int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## nonzero_local.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int r0 = 2;
int r0 = 0;
void
P0()
{
    atomic_compare_exchange_strong_explicit(&x, &r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1()
{
    atomic_compare_exchange_strong_explicit(&x, &r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 1) \\/ (0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int r0 = 2;
int r0 = 0;
void
P0_body()
{
    atomic_compare_exchange_strong_explicit(&x, &r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body()
{
    atomic_compare_exchange_strong_explicit(&x, &r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 1) \\/ (0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int t0r0 = 2;
int t1r0 = 0;
void
P0()
{
    atomic_compare_exchange_strong_explicit(&x, &t0r0, 1,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1()
{
    atomic_compare_exchange_strong_explicit(&x, &t1r0, 2,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((t0r0 == 0 /\\ t1r0 == 0 /\\ x == 1) \\/ (t0r0 == 0 /\\ t1r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
int t0r0 = 2;
int t1r0 = 0;
void
P0_body()
{
    atomic_compare_exchange_strong_explicit(&x, &t0r0, 1,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body()
{
    atomic_compare_exchange_strong_explicit(&x, &t1r0, 2,
                                            memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((t0r0 == 0 /\\ t1r0 == 0 /\\ x == 1) \\/ (t0r0 == 0 /\\ t1r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Global" ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, int *r0)
{
    atomic_compare_exchange_strong_explicit(x, r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1(atomic_int *x, int *r0)
{
    atomic_compare_exchange_strong_explicit(x, r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 1) \\/ (0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, int *r0)
{
    atomic_compare_exchange_strong_explicit(x, r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body(atomic_int *x, int *r0)
{
    atomic_compare_exchange_strong_explicit(x, r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 1) \\/ (0:r0 == 0 /\\ 1:r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, int *t0r0)
{
    atomic_compare_exchange_strong_explicit(x, t0r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1(atomic_int *x, int *t1r0)
{
    atomic_compare_exchange_strong_explicit(x, t1r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((t0r0 == 0 /\\ t1r0 == 0 /\\ x == 1) \\/ (t0r0 == 0 /\\ t1r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, int *t0r0)
{
    atomic_compare_exchange_strong_explicit(x, t0r0, 1, memory_order_relaxed,
                                            memory_order_relaxed);
}
void
P1_body(atomic_int *x, int *t1r0)
{
    atomic_compare_exchange_strong_explicit(x, t1r0, 2, memory_order_relaxed,
                                            memory_order_relaxed);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "test_8",
    "locations": null,
    "init": { "x": 0 },
    "postcondition":
      "forall\n((t0r0 == 0 /\\ t1r0 == 0 /\\ x == 1) \\/ (t0r0 == 0 /\\ t1r0 == 0 /\\ x == 2))"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "0:r0": {
      "c_type": "int",
      "c_id": "t0r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 2
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```
## rwc.c.litmus

```
//
// style: vars-as-globals
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
void
P0()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P2()
{
    atomic_store_explicit(&y, 1, memory_order_seq_cst);
    r0 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 1 /\\ 1:r1 == 0 /\\ 2:r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int r0 = 0;
int r1 = 0;
int r0 = 0;
void
P0_body()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1_body()
{
    r0 = atomic_load_explicit(&x, memory_order_acquire);
    r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P2_body()
{
    atomic_store_explicit(&y, 1, memory_order_seq_cst);
    r0 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 1 /\\ 1:r1 == 0 /\\ 2:r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t1r0 = 0;
int t1r1 = 0;
int t2r0 = 0;
void
P0()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1()
{
    t1r0 = atomic_load_explicit(&x, memory_order_acquire);
    t1r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P2()
{
    atomic_store_explicit(&y, 1, memory_order_seq_cst);
    t2r0 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 1 /\\ t1r1 == 0 /\\ t2r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "t1r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-globals
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
atomic_int x = 0;
atomic_int y = 0;
int t1r0 = 0;
int t1r1 = 0;
int t2r0 = 0;
void
P0_body()
{ atomic_store_explicit(&x, 1, memory_order_seq_cst); }
void
P1_body()
{
    t1r0 = atomic_load_explicit(&x, memory_order_acquire);
    t1r1 = atomic_load_explicit(&y, memory_order_seq_cst);
}
void
P2_body()
{
    atomic_store_explicit(&y, 1, memory_order_seq_cst);
    t2r0 = atomic_load_explicit(&x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 1 /\\ t1r1 == 0 /\\ t2r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "t1r1",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Global" ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P2(atomic_int *x, atomic_int *y, int *r0)
{
    atomic_store_explicit(y, 1, memory_order_seq_cst);
    *r0 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 1 /\\ 1:r1 == 0 /\\ 2:r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: false
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1_body(atomic_int *x, atomic_int *y, int *r0, int *r1)
{
    *r0 = atomic_load_explicit(x, memory_order_acquire);
    *r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P2_body(atomic_int *x, atomic_int *y, int *r0)
{
    atomic_store_explicit(y, 1, memory_order_seq_cst);
    *r0 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (1:r0 == 1 /\\ 1:r1 == 0 /\\ 2:r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: (none)
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1(atomic_int *x, atomic_int *y, int *t1r0, int *t1r1)
{
    *t1r0 = atomic_load_explicit(x, memory_order_acquire);
    *t1r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P2(atomic_int *x, atomic_int *y, int *t2r0)
{
    atomic_store_explicit(y, 1, memory_order_seq_cst);
    *t2r0 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 1 /\\ t1r1 == 0 /\\ t2r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0" },
    "P1": { "is_thread_body": true, "c_id": "P1" },
    "P2": { "is_thread_body": true, "c_id": "P2" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "t1r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
//
// style: vars-as-parameters
// qualify-locals: true
// suffix: _body
//

// <!> Auto-generated from a litmus test by ACT.
#include <stdatomic.h>
#include <stdbool.h>
void
P0_body(atomic_int *x, atomic_int *y)
{ atomic_store_explicit(x, 1, memory_order_seq_cst); }
void
P1_body(atomic_int *x, atomic_int *y, int *t1r0, int *t1r1)
{
    *t1r0 = atomic_load_explicit(x, memory_order_acquire);
    *t1r1 = atomic_load_explicit(y, memory_order_seq_cst);
}
void
P2_body(atomic_int *x, atomic_int *y, int *t2r0)
{
    atomic_store_explicit(y, 1, memory_order_seq_cst);
    *t2r0 = atomic_load_explicit(x, memory_order_seq_cst);
}

/* --Begin auxiliary output--

{
  "litmus_header": {
    "name": "rwc",
    "locations": null,
    "init": { "x": 0, "y": 0 },
    "postcondition": "exists (t1r0 == 1 /\\ t1r1 == 0 /\\ t2r0 == 0)"
  },
  "function_map": {
    "P0": { "is_thread_body": true, "c_id": "P0_body" },
    "P1": { "is_thread_body": true, "c_id": "P1_body" },
    "P2": { "is_thread_body": true, "c_id": "P2_body" }
  },
  "var_map": {
    "x": {
      "c_type": "atomic_int",
      "c_id": "x",
      "mapped_to": [ "Param", 0 ],
      "initial_value": 0
    },
    "y": {
      "c_type": "atomic_int",
      "c_id": "y",
      "mapped_to": [ "Param", 1 ],
      "initial_value": 0
    },
    "1:r0": {
      "c_type": "int",
      "c_id": "t1r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    },
    "1:r1": {
      "c_type": "int",
      "c_id": "t1r1",
      "mapped_to": [ "Param", 3 ],
      "initial_value": 0
    },
    "2:r0": {
      "c_type": "int",
      "c_id": "t2r0",
      "mapped_to": [ "Param", 2 ],
      "initial_value": 0
    }
  }
} 
--End auxiliary output-- */
```

Ran 8 test(s).
