(* The Automagic Compiler Tormentor

   Copyright (c) 2018--2019 Matt Windsor and contributors

   ACT itself is licensed under the MIT License. See the LICENSE file in the
   project root for more information.

   ACT is based in part on code from the Herdtools7 project
   (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
   project root for more information. *)

(** Fuzz metadata.

    This module defines a type for metadata records attached to parts of a
    fuzzer subject. Such metadata tracks things like:

    - whether a piece of code was generated by the fuzzer, or exists in the
      original subject;
    - whether a piece of code is regarded as 'dead code'. *)

open Base

(** {1 Metadata record components} *)

(** {2 Liveness}

    We consider existing nodes to be live with an arbitrary number of
    executions.

    Since metadata can be nested through nested statements and expressions,
    the liveness of inner nodes may be shadowed by that of outer nodes, and
    vice versa For example, a statement we assume is live might live inside a
    dead-code block, and a block executing only once might contain a loop
    that executes several times. This is considered normal, and the fuzzer
    doesn't at present have any means of preventing it. *)
module Liveness : sig
  (** Type of liveness analyses. *)
  type t =
    | Dead  (** This node is known to be 'dead', ie it will never execute. *)
    | Once
        (** This node is known to execute only once.

            This liveness can be attached to, for instance, loops that are
            statically designed to execute once, or if-branches that are
            known to be taken always. *)
    | Live
        (** This node is known, or presumed, to execute an arbitrary number
            of times.

            This is usually the default liveness when no other specific
            liveness information is needed or given. *)
  [@@deriving accessors, sexp, compare, equal]

  val is_dead : t -> bool
  (** [is_dead x] is true if, and only if, [x] is [Dead]. *)
end

(** {2 Specific restriction flags}

    We consider existing nodes to have all restriction flags enabled. *)
module Restriction : sig
  (** Type of individual restriction flags. *)
  type t =
    | Once_only
        (** This node is not safe to execute an arbitrary number of times.

            Any action that wraps this node inside another node must make
            sure that it doesn't introduce the possibility of arbitrary
            executions. *)
  [@@deriving accessors, sexp, compare, equal]

  include Comparable.S with type t := t
end

(** {2 Generated-node metadata} *)

module Gen : sig
  (** Type of generated-node records. *)
  type t = {liveness: Liveness.t; restrictions: Set.M(Restriction).t}
  [@@deriving accessors, sexp, compare, equal]

  val make :
    ?liveness:Liveness.t -> ?restrictions:Set.M(Restriction).t -> unit -> t
  (** [make ?liveness ?restrictions ()] makes a generated metadata record
      with the given liveness (defaulting to 'live') and restrictions
      (defaulting to nothing). *)
end

(** {1 Metadata records} *)

(** Type of metadata records.

    Such records track whether a FIR node is existing (in which case, it is
    considered an unknown quantity), or fuzzer-generated. *)
type t = Existing | Generated of Gen.t
[@@deriving accessors, sexp, compare, equal]

(** {2 Shorthand constructors} *)

val gen_normal : t
(** [gen_normal] is metadata marking the recipient as generated code with no
    restrictions and no assumptions about executions. *)

val gen_once : t
(** [gen_once] is metadata marking the recipient as generated code with no
    restrictions and the assumption that the code will be executed once. *)

val gen_dead : t
(** [gen_dead] is metadata marking the recipient as generated dead-code with
    no restrictions. *)

(** {2 Getters and predicates} *)

val liveness : t -> Liveness.t
(** [liveness m] is the liveness of [m], defaulting to [Live] if [m] is
    existing. *)

val has_restriction : Restriction.t -> t -> bool
(** [has_restriction m] is true provided that [m] has the given restriction.
    Existing code is conservatively considered to have all restrictions set. *)
