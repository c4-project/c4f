(* This file is part of c4f.

   Copyright (c) 2018-2021 C4 Project

   c4t itself is licensed under the MIT License. See the LICENSE file in the
   project root for more information.

   Parts of c4t are based on code from the Herdtools7 project
   (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
   project root for more information. *)

(** Post-delitmus variable maps.

    These maps primarily associate Litmus IDs with the global symbols into
    which the delitmusifier has flattened them. *)

open Base
open Import

(** {1 Mapping information}

    {!Mapping} contains an enumeration of ways in which a variable in a
    Litmus test maps to a variable in the delitmusified form. *)

module Mapping : sig
  (** Type of mappings. *)
  type t =
    | Global  (** Mapped to a global variable. *)
    | Param of int
        (** Mapped to a parameter with the given index. If the variable was a
            global variable, it is mapped to this index on all functions. If
            the variable was a thread variable, it is only mapped to that
            index on that variable. *)
  [@@deriving yojson, equal]
end

(** {1 Records} *)

module Record : sig
  (** Type of delitmus variable records. *)
  type t =
    { c_type: Fir.Type.t
    ; c_id: Common.C_id.t
    ; mapped_to: Mapping.t
    ; initial_value: Fir.Constant.t option }
  [@@deriving accessors, yojson, equal]

  val mapped_to_global : t -> bool
  (** [mapped_to_global r] gets whether [r]'s variable has been mapped into
      the global scope. *)

  val mapped_to_param : t -> bool
  (** [mapped_to_param r] gets whether [r]'s variable has been mapped into a
      parameter. *)
end

(** Delitmus variable maps are a specific case of scoped map. *)
type t = Record.t Common.Scoped_map.t [@@deriving equal]

(** {1 Projections specific to delitmus variable maps} *)

val param_mapped_vars : t -> (Common.Litmus_id.t, Record.t) List.Assoc.t
(** [param_mapped_vars vm] extracts an associative list of variables from
    [vm] that are intended to be mapped to parameters. The list is sorted by
    parameter index, not by litmus ID. *)

val params_for_thread :
  t -> int -> (Common.Litmus_id.t, Record.t) List.Assoc.t
(** [params_for_thread vm tid] extracts an associative list of variables from
    [vm] that are intended to be mapped to the parameters of thread [tid].
    The list is sorted by parameter index, not by litmus ID. *)

val globally_mapped_vars : t -> (Common.Litmus_id.t, Record.t) List.Assoc.t
(** [globally_mapped_vars vm] extracts an associative list of variables from
    [vm] that are intended to be mapped to global variables. The list is
    sorted by litmus ID. *)

val global_c_variables : t -> Set.M(Common.C_id).t
(** [global_c_variables map] gets the set of global C variables generated by
    the delitmusifier over [map]. *)

val lookup_and_require_global :
  t -> id:Common.Litmus_id.t -> Common.C_id.t Or_error.t
(** [lookup_and_require_global map ~id] looks up the Litmus ID [id] in the
    var map. It returns [x] if [id] was mapped to a global C variable [id] in
    [map], or an error otherwise (ie, [id] was not mapped to a global C
    variable, or not seen at all). *)

val lookup_and_require_param :
  t -> id:Common.Litmus_id.t -> Common.C_id.t Or_error.t
(** [lookup_and_require_param map ~id] behaves as
    {!lookup_and_require_global}, but instead requires that [id] was mapped
    to a function parameter. *)

(** {2 Interface implementations} *)

(** A var map can be serialised to, and deserialised from, (Yo)JSON. *)
include Plumbing.Jsonable_types.S with type t := t
